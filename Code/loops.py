#Lewis Mazzei - Fusion/Code/loops.py
#Note: If a comment is not on the same line then the corresponding comment to a line or chunk of code will be above it

#import relevant packages
import pygame, re, os, pickle, random
from datetime import datetime #TO BE REMOVED BEFORE PRINTING
#import gameboard class
from gameboard import Gameboard
#setup file: includes all functions needed for setting up pygame window and some constant variables needed throughout the process of running the game
from setup import DISPLAY_WIDTH, DISPLAY_HEIGHT, display, clock, BLACK, WHITE, gridDictCoords, gridDictDimensions, elementSymbols
#drawing file: includes all functions required to draw the different screens and their elements 
from drawing import font, createTextObjects, drawButton, drawLabel, drawInputBox, drawGameScreenHeader, drawGameBoard, drawTiles, drawGameScreen, drawMainMenuScreen, drawInstructionsScreen, drawNameInputScreen, drawLeaderboardGrid, drawLeaderboardContents, drawLeaderboardScreen, drawOptionsScreen

#used for testing how long certain operations take (for non-functional testing)
def getTime():
	time = datetime.utcnow().strftime('%H:%M:%S.%f')[:-3] #gets the current time (down to milliseconds) and formats it

	return time #returns this timestamp

#program keeps looping through this whilst on the 'game' screen
def gameLoop(gameboard):
	if len(gameboard.tiles) == 0: # if the board is empty, i.e. it's a new game...
		gameboard.spawn() #...start the game with one spawn
	running = True #by default the game is 'running' (i.e. has not been quit out of or has crashed)
	while running: #will not stop looping unless broken out of by force using a 'break'/'return' statement or a 'quit' type event has been triggered
		features = drawGameScreen(gameboard) #draw the elements of the game screen and store the properties of them inside an array called 'features'
		for event in pygame.event.get(): #for each event in the current event queue
			if event.type == pygame.QUIT: #if the type of event is a 'quit' (i.e. the red x has been clicked or an alternative quit command is entered)...
				running = False #...then flag this fact so that the loop is broken out of
			elif event.type == pygame.KEYDOWN: #if the event type is a 'key press'...
				if event.key == pygame.K_LEFT: #...and it is the left key that has been pressed...
					if gameboard.tilesLeft(): #...then move the tiles to the left...
						initSpawn(gameboard) #...and decide whether to spawn new tile(s) or to end the game
				elif event.key == pygame.K_RIGHT: #...and it is the right key that has been pressed...
					if gameboard.tilesRight(): #...then move the tiles to the right...
						initSpawn(gameboard) #...and decide whether to spawn new tile(s) or to end the game
				elif event.key == pygame.K_UP: #...and it is the up key that has been pressed...
					if gameboard.tilesUp(): #...then move the tiles up...
						initSpawn(gameboard) #...and decide whether to spawn new tile(s) or to end the game
				elif event.key == pygame.K_DOWN: #...and it is the down that has been pressed...
					if gameboard.tilesDown(): #...then move the tiles dwon...
						initSpawn(gameboard) #...and decide whether to spawn new tile(s) or to end the game
			mouse = pygame.mouse.get_pos() #get the position of the mouse
			if event.type == pygame.MOUSEBUTTONUP: #if the user clicks...
				if features[4].collidepoint(mouse): #...and the position of the mouse is within the bounds of the the 'options' button...
					optionsLoop() #...then switch to the 'options' screen

			drawGameScreen(gameboard) #draw the screen with the updated block positions and score
			pygame.display.update() #and update the screen

			for tile in gameboard.tiles: #for each tile...
				if tile.element % 11 == 0: #...if the tile is the eleventh element (works for every level using moduulus)...
					pygame.time.wait(1000) #...wait 1000ms...
					display.fill(WHITE) #...wipe the screen...
					drawLabel('Level Complete', font(50), BLACK, ((DISPLAY_WIDTH / 2), (DISPLAY_HEIGHT / 2))) #...draw 'level complete' onto the screen...
					pygame.display.update() #...update the screen with this message...
					pygame.time.wait(1000) #...wait another 1000ms...
					if gameboard.level < 11: #...if the level being completed is not the 11th...
						gameboard.level += 1 #...then increment the level...
						gameboard.state = [['Empty' for col in range(5)] for row in range(5)] #...reset the game state to an empty grid...
						gameboard.tiles = [] #...empty the arroy of tiles...
						gameboard.spawn() #...and spawn the first block for that new level
						break #break out of this 'for' loop
					else: #if the player has completed all 11 levels...
						pygame.time.wait(1000) #...wait 1000ms...
						display.fill(WHITE) #...wipe the screen...
						drawLabel('Level Complete', font(50), BLACK, ((DISPLAY_WIDTH / 2), (DISPLAY_HEIGHT / 2))) #...draw 'game complete' onto the screen...
						pygame.display.update() #...update the screen with this message...
						pygame.time.wait(1000) #...wait another 1000ms...
						leaderboardLoop() #...then go to leaderboard screen
				
		saveGameState(gameboard) #save the game state after every iteration of this 'event' loop ('autosave' feature)
		pygame.display.update() #update the screen with any new drawings
		clock.tick(120) #the game should run at a frame rate of 120 frames per second

	pygame.quit() #if the game is not 'running' anymore then quit out of pygame

#program keeps looping through this whilst on the 'main menu' screen
def mainMenuLoop():
	running = True #by default the game is 'running' (i.e. has not been quit out of or has crashed)
	while running: #will not stop looping unless broken out of by force using a 'break'/'return' statement or a 'quit' type event has been triggered
		features = drawMainMenuScreen() #draw the elements of the 'game' screen and store the properties of them inside an array called 'features'
		for event in pygame.event.get(): #for each event in the current event queue
			if event.type == pygame.QUIT: #if the type of event is a 'quit' (i.e. the red x has been clicked or an alternative quit command is entered)...
				running = False #...then flag this fact so that the loop is broken out of
			mouse = pygame.mouse.get_pos() #get the position of the mouse
			if event.type == pygame.MOUSEBUTTONUP: #if the user clicks...
				if features[0].collidepoint(mouse): #...and the position of the mouse is within the bounds of the the 'new game' button...
					nameInputLoop(newGame = True) #...then switch to the 'name input' screen with the 'newGame' flag set to true 
				elif features[1].collidepoint(mouse): #...and the position of the mouse is within the bounds of the the 'load game' button...
					nameInputLoop(newGame = False)  #...then switch to the 'name input' screen with the 'newGame' flag set to false
				elif features[2].collidepoint(mouse): #...and the position of the mouse is within the bounds of the the 'new game' button...
					leaderboardLoop() #...then switch to the 'leaderboard' screen
				elif features[3].collidepoint(mouse): #...and the position of the mouse is within the bounds of the the 'new game' button...
					print('start: ', getTime())
					instructionsLoop() #...then switch to the 'instructions' screen

		pygame.display.update() #update the screen 
		clock.tick(120) #the game should run at a frame rate of 120 frames per second
	pygame.quit() #if the game is not 'running' anymore then quit out of pygame

#program keeps looping through this whilst on the 'instructions' screen
def instructionsLoop():
	print('end: ', getTime())
	running = True #by default the game is 'running' (i.e. has not been quit out of or has crashed)
	while running: #will not stop looping unless broken out of by force using a 'break'/'return' statement or a 'quit' type event has been triggered
		features = drawInstructionsScreen() #draw the elements of the 'instructions' screen and store the properties of them inside an array called 'features'
		for event in pygame.event.get(): #for each event in the current event queue
			if event.type == pygame.QUIT: #if the type of event is a 'quit' (i.e. the red x has been clicked or an alternative quit command is entered)...
				running = False #...then flag this fact so that the loop is broken out of
			mouse = pygame.mouse.get_pos() #get the position of the mouse
			if event.type == pygame.MOUSEBUTTONUP: #if the user clicks...
				if features[0].collidepoint(mouse): #...and the position of the mouse is within the bounds of the the 'back' button...
					return #...then switch back to the 'main menu' screen by returning nothing and breaking out of the instructions 'loop', back into the 'main menu' loop
		pygame.display.update() #update the screen
		clock.tick(120) #the game should run at a frame rate of 120 frames per second
	pygame.quit() #if the game is not 'running' anymore then quit out of pygame

#program keeps looping through this whilst on the 'name input' screen
def nameInputLoop(newGame):
	running = True #by default the game is 'running' (i.e. has not been quit out of or has crashed)
	username = [] #initialise the username to an empty list of characters
	while running: #will not stop looping unless broken out of by force using a 'break'/'return' statement or a 'quit' type event has been triggered
		features = drawNameInputScreen(newGame, username) #draw the elements of the 'game' screen and store the properties of them inside an array called 'features'
		for event in pygame.event.get(): #for each event in the current event queue
			if event.type == pygame.QUIT: #if the type of event is a 'quit' (i.e. the red x has been clicked or an alternative quit command is entered)...
				running = False #...then flag this fact so that the loop is broken out of
			mouse = pygame.mouse.get_pos() #get the position of the mouse
			if event.type == pygame.MOUSEBUTTONUP: #if the user clicks...
				if features[2].collidepoint(mouse): #...and the position of the mouse is within the bounds of the the input box...
					clickedInBox = True #...then flag this fact...
					while clickedInBox and running: #...and loop whilst they haven't clicked outside the box and haven't quit
						pygame.draw.rect(display, (255, 0, 0), [150, 310, 200, 30], 2) #change the border of the input box to red to indicate that the box has been clicked on
						for event in pygame.event.get(): #for each event in the event queue (an internal event queue loop is needed as we have now entered a secondary while loop)
							mouse = pygame.mouse.get_pos() #variable that holds the current coordinate of the mouse
							if event.type == pygame.QUIT: #if the type of event is a 'quit' (i.e. the red x has been clicked or an alternative quit command is entered)...
								running = False #...then flag this fact so that the loop is broken out of
							elif event.type == pygame.MOUSEBUTTONUP: #if the user clicks...
								if not features[2].collidepoint(mouse): #...outwith the input box...
									if features[3].collidepoint(mouse): #...and within the 'enter' button (or enter key is pressed)...
										if len(list(username)) >= 3: #...and username has the minimum number of characters...
											usernameSubmitted(newGame, username) #...then submit that username
										else: #if the username is not long enough...
											drawLabel('Username needs to be at least 3 characters!', font(25), BLACK, (250, 450)) #...draw a message saying so...
											pygame.display.update() #...display it...
											pygame.time.wait(500) #...for a brief moment...
											drawNameInputScreen(newGame, username) #...and then draw the screen again, covering/hiding the message 
									if features[4].collidepoint(mouse): #if the user clicks outwith the input box and within the 'Back' button then...
										return #...return to main menu
									else: #a click anywhere else and we will...
										clickedInBox = False #...flag this fact...
										break #...and break out of this loop, returning to the 'not clicked in box' loop
							elif event.type == pygame.KEYDOWN: #if the user presses the...
								if event.key == pygame.K_RETURN: #...return key...
									if len(list(username)) >= 3: #...then check username has the minimum number of characters...
										usernameSubmitted(newGame, username) #...then either load a game using that username or start a new one
									else:
										drawLabel('Username needs to be at least 3 characters!', font(25), BLACK, (250, 450)) #...draw a message saying so...
										pygame.display.update() #...display it...
										pygame.time.wait(500) #...for a brief moment...
										drawNameInputScreen(newGame, username) #...and then draw the screen again, covering/hiding the message 
								elif event.key == pygame.K_BACKSPACE: #...backspace...
									if len(username) > 0: #...check that the current username has characters to prevent an 'out of bounds' exception being raised on the username array
										username = list(username) #convert the username into a list...
										del username[-1] #...remove the last char from the list...
										username = ''.join(username) #...join that list back into a string...
										drawNameInputScreen(newGame, username) #...and draw the updated username inside the input box
								elif len(username) < 8: #if the press another key then first check we don't end up putting more than 8 chars into the string
									if re.match('[a-z0-9]', chr(event.key)): #if they press a key between a-z or 0-9 (regex)...
										username = list(username) #...convert the username into a list
										username.append(chr(event.key)) #...add that character to the list...
										username = ''.join(username) #...join that list back into a string
										drawNameInputScreen(newGame, username) #...and draw the updated username inside the input box
									else: #if they press any other key...
										drawLabel('Invalid character!', font(25), BLACK, (250, 450)) #...draw a message saying so...
										pygame.display.update() #...display it...
										pygame.time.wait(500) #...for a brief moment...
										username = ''.join(username) #...join the username list into a string...
										drawNameInputScreen(newGame, username) #...and then draw the screen again, covering/hiding the message
								else: #if they press another key but the string already has 8 chars then...
									drawLabel('Only allowed up to 8 characters!', font(25), BLACK, (250, 450)) #...draw a message saying so...
									pygame.display.update() #...display it...
									pygame.time.wait(500) #...for a brief moment...
									drawNameInputScreen(newGame, username) #...and then draw the screen again, covering/hiding the message 
						pygame.display.update() #update the display with anything that has been drawn (new chars inside the input box)
						clock.tick(120)  #the game should run at a frame rate of 120 frames per second
				elif features[3].collidepoint(mouse) and len(list(username)) >= 3 and len(list(username)) <= 8: #if the start/continue button is clicked and username is valid...
					usernameSubmitted(newGame, username) #...submit it
				elif features[3].collidepoint(mouse) and len(list(username)) < 3: #if the start/continue button is clicked and the username is too short...
					drawLabel('Username needs to be at least 3 characters!', font(25), BLACK, (250, 450)) #...draw a message saying so...
					pygame.display.update() #...display it...
					pygame.time.wait(500) #...for a brief moment...
					drawNameInputScreen(newGame, username) #...and then draw the screen again, covering/hiding the message 
				elif features[3].collidepoint(mouse) and len(list(username)) > 8: #if the start/continue button is clicked and the username is too long...
					drawLabel('Only allowed up to 8 characters!', font(25), BLACK, (250, 450)) #...draw a message saying so...
					pygame.display.update() #...display it...
					pygame.time.wait(500) #...for a brief moment...
					drawNameInputScreen(newGame, username) #...and then draw the screen again, covering/hiding the message 
				elif features[4].collidepoint(mouse): #if the 'back' button is clicked...
					return #...then switch back to the 'main menu' screen by returning nothing and breaking out of the 'name input' loop, back into the 'main menu' loop
		pygame.display.update() #update the screen
		clock.tick(120) #the game should run at a frame rate of 120 frames per second
	pygame.quit() #if the game is not 'running' anymore then quit out of pygame

#program keeps looping through this whilst on the 'instructions' screen
def leaderboardLoop(gameOver = False):
	running = True #by default the game is 'running' (i.e. has not been quit out of or has crashed)
	while running: #will not stop looping unless broken out of by force using a 'break'/'return' statement or a 'quit' type event has been triggered
		features = drawLeaderboardScreen() #draw the elements of the 'leaderboard' screen and store the properties of them inside an array called 'features'
		for event in pygame.event.get(): #for each event in the current event queue
			if event.type == pygame.QUIT: #if the type of event is a 'quit' (i.e. the red x has been clicked or an alternative quit command is entered)...
				running = False #...then flag this fact so that the loop is broken out of
			mouse = pygame.mouse.get_pos() #get the position of the mouse
			if event.type == pygame.MOUSEBUTTONUP: #if the type of event is a 'mouse button up' (i.e. the mouse button has been lifted after being pressed down)...
				if features[1].collidepoint(mouse) and gameOver: #if this screen is up just after the game is over then back button...
					mainMenuLoop() #...returns user to the main menu 
				elif features[1].collidepoint(mouse): #if the screen accessed from anywhere else...
					return #...this button returns user to the previous screen

		pygame.display.update() #update the screen
		clock.tick(120) #the game should run at a frame rate of 120 frames per second
	pygame.quit() #if the game is not 'running' anymore then quit out of pygame

#program keeps looping through this whilst on the 'options' screen
def optionsLoop():
	running = True #by default the game is 'running' (i.e. has not been quit out of or has crashed)
	while running:  #will not stop looping unless broken out of by force using a 'break'/'return' statement or a 'quit' type event has been triggered
		features = drawOptionsScreen() #draw the elements of the 'instructions' screen and store the properties of them inside an array called 'features'
		for event in pygame.event.get(): #for each event in the current event queue
			if event.type == pygame.QUIT: #if the type of event is a 'quit' (i.e. the red x has been clicked or an alternative quit command is entered)...
				running = False #...then flag this fact so that the loop is broken out of
			mouse = pygame.mouse.get_pos() #get the position of the mouse
			if event.type == pygame.MOUSEBUTTONUP: #if the user clicks...
				if features[1].collidepoint(mouse): #...and the position of the mouse is within the bounds of the the 'leaderboard' button...
					leaderboardLoop() #then switch to the 'leaderboard' screen
				elif features[2].collidepoint(mouse): #...and the position of the mouse is within the bounds of the the 'main menu' button...
					mainMenuLoop() #then switch to the 'main menu' screen
				elif features[3].collidepoint(mouse): #...and the position of the mouse is within the bounds of the the 'continue' button...
					return #...then switch back to the 'game' screen by returning nothing and breaking out of the 'options' loop, back into the 'game' loop
		
		pygame.display.update() #update the screen
		clock.tick(120) #the game should run at a frame rate of 120 frames per second
	pygame.quit() #if the game is not 'running' anymore then quit out of pygame

#used when a valid username is submitted
def usernameSubmitted(newGame, username):
	found = False #be default, assume that the name will not be found within the 'game saves' folder
	for fileName in os.listdir('/home/lewis/Documents/School/Fusion/External Files/Game Saves'): #for each file in the 'game saves' folder
		if fileName == '{}.pickle'.format(username): #if a currently unfinished game is being stored using that username...
			found = True #...then flag this fact
	if found: #if the name was found within the folder 
		if newGame: #...and it's a new game then the user will not be able to pick this name
			drawLabel('This username is currently being used.', font(25), BLACK, (250, 450)) #...so draw a message saying so...
			drawLabel('Please use another one.', font(25), BLACK, (250, 480))
			pygame.display.update() #...display it...
			pygame.time.wait(500) #...for a brief moment...
			drawNameInputScreen(newGame, username) #...and then draw the screen again, covering/hiding the message
		else: #if the user is loading a game and the name exists...
			gameboard = openGameSave(username) #...then reload the gameboard attributes from that file into a new gameboard object...
			gameLoop(gameboard) #...and start the game from the point that user left off
	else: #if the name is not found...
		if newGame: #...and the user is starting a new game
			 gameboard = Gameboard(username = username, state = [['Empty' for col in range(5)] for row in range(5)], level = 1, tiles = [], score = 0) #... then instantiate a new gameboard with the username entered...
			 gameLoop(gameboard) #...and start a new game
		else: #if the user is trying to load a game with a name that does not exist within the 'game saves' folder...
			drawLabel('This username is not currently being used', font(25), BLACK, (250, 450)) #...then draw a message saying so...
			pygame.display.update() #...display it...
			pygame.time.wait(500) #...for a brief moment...
			drawNameInputScreen(newGame, username) #...and then draw the screen again, covering/hiding the message

#used to sort the scores in the 'leaderboard' file when a new score is entered
def bubbleSort(lst):
	for i in range(len(lst)): #for every element in the list
		for j in range(i + 1, len(lst)): #for every element in the list past the first one
			if lst[j][1] < lst[i][1]: #check if the element to the right is less than the one to the left
				lst[j], lst[i] = lst[i], lst[j] #if so then they are in the wrong order so 'bubble' the element to the left and swap it's location with the one to the right

#used to save the game state to that game's corresponding 'game save' file
def saveGameState(gameboard):
	with open('/home/lewis/Documents/School/Fusion/External Files/Game Saves/{}.pickle'.format(gameboard.username), 'wb') as file: #open the relevant 'game save' file...
		pickle.dump([gameboard.username, gameboard.state, gameboard.level, gameboard.tiles, gameboard.score], file) #...and write all the current gameboard attributes to it

#used to open a 'game save' when a user wants to load an unfinished game
def openGameSave(username):
	with open('/home/lewis/Documents/School/Fusion/External Files/Game Saves/{}.pickle'.format(username), 'rb') as file: #open the relevant 'game save' file
		username, state, level, tiles, score = pickle.load(file) #load all the gameboard attributes into corresponding variables...
		return Gameboard(username, state, level, tiles, score) #...so that we can then return the gameboard with the attributes it had when the user left the game

#used to delete 'game save' files when a game is over (as it may not be loaded up again)
def deleteGameSave(username):
	os.remove('/home/lewis/Documents/School/Fusion/External Files/Game Saves/{}.pickle'.format(username)) #remove the relevant 'game save' file from the 'games saves' folder

#used to check whether the game is over or whether more tiles should be spawned onto the game board
def initSpawn(gameboard):
	if random.randint(0, 1) == 0: #create a 50/50 chance that either...
		if gameboard.spawn() == True or len(gameboard.tiles) == 25: #...one tile will be spawned, and if that tile causes the gameboard to overflow then...
			updateLeaderboard(gameboard) #...update the leaderboard with the user's score (if it makes the top 10)...
			deleteGameSave(gameboard.username) #...delete the user's game save...
			leaderboardLoop(gameOver = True) #...and then switch to the leaderboard screen
	else: #...or...
		if gameboard.spawn() == True or len(gameboard.tiles) == 25: #...two tiles will be spawned, and if the first of those tiles causes the game board to overflow then... 
			updateLeaderboard(gameboard) #...update the leaderboard with the user's score (if it makes the top 10)...
			deleteGameSave(gameboard.username) #...delete the user's game save..
			leaderboardLoop(gameOver = True) #...and then switch to the leaderboard screen
		elif gameboard.spawn() == True or len(gameboard.tiles) == 25: #if the second tile causes the gameboard to overflow then...
			updateLeaderboard(gameboard) #...update the leaderboard with the user's score (if it makes the top 10)...
			deleteGameSave(gameboard.username) #...delete the user's game save..
			leaderboardLoop(gameOver = True) #...and then switch to the leaderboard screen

#used for checking whether the leaderboard needs to be updated with a new score, and if so then does this, removing the bottom most score
def updateLeaderboard(gameboard):
	firstNameEntered = False #assume that the list either has 0 entries or more than 1
	with open('/home/lewis/Documents/School/Fusion/External Files/Leaderboard.pickle', 'rb') as file: #open leaderboard file
		try:
			namesAndScores = pickle.load(file) #read file and grab the current list of names and scores...
		except EOFError: #...unless there's nothing in the file, i.e. leaderboard has been wiped
			namesAndScores = [(gameboard.username, gameboard.score)] #if this is the case just set the first element of the list to the current user's name and score
			firstNameEntered = True # flag the fact that there is only one entry in the list
		if len(namesAndScores) < 10 and not firstNameEntered: #...and the list has less than more than 1 entry but less 10 entries...
			namesAndScores.append((gameboard.username, gameboard.score)) #...then just append that user's name and score to the list...
			bubbleSort(namesAndScores) #...and then put that score into place with a sort, the name and score will 'bubble' to the correct position
		elif gameboard.score > namesAndScores[0][1]: #if the current list already has 10 entries and the current score is higher than the lowest score in the list...
			namesAndScores[0] = (gameboard.username, gameboard.score) #...then replace that score... 
			bubbleSort(namesAndScores) #...and sort the list
	with open('/home/lewis/Documents/School/Fusion/External Files/Leaderboard.pickle', 'wb') as file: #open the 'leaderboard' file...
		pickle.dump(namesAndScores, file) #...and write the updated/sorted 'namesAndScores' list to it